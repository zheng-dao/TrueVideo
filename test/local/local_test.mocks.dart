// Mocks generated by Mockito 5.1.0 from annotations
// in truvideo_enterprise/test/local/local_test.dart.
// Do not manually edit this file.

import 'dart:async' as _i3;

import 'package:mockito/mockito.dart' as _i1;
import 'package:streaming_shared_preferences/src/adapters/adapters.dart' as _i5;
import 'package:streaming_shared_preferences/src/preference/preference.dart'
    as _i2;
import 'package:streaming_shared_preferences/src/streaming_shared_preferences.dart'
    as _i4;

import 'local_test.dart' as _i6;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types

class _FakePreference_0<T> extends _i1.Fake implements _i2.Preference<T> {}

class _FakeStreamSubscription_1<T> extends _i1.Fake
    implements _i3.StreamSubscription<T> {}

/// A class which mocks [StreamingSharedPreferences].
///
/// See the documentation for Mockito's code generation for more information.
class MockStreamingSharedPreferences extends _i1.Mock
    implements _i4.StreamingSharedPreferences {
  MockStreamingSharedPreferences() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.Preference<Set<String>> getKeys() =>
      (super.noSuchMethod(Invocation.method(#getKeys, []),
              returnValue: _FakePreference_0<Set<String>>())
          as _i2.Preference<Set<String>>);
  @override
  _i2.Preference<bool> getBool(String? key, {bool? defaultValue}) =>
      (super.noSuchMethod(
          Invocation.method(#getBool, [key], {#defaultValue: defaultValue}),
          returnValue: _FakePreference_0<bool>()) as _i2.Preference<bool>);
  @override
  _i2.Preference<int> getInt(String? key, {int? defaultValue}) =>
      (super.noSuchMethod(
          Invocation.method(#getInt, [key], {#defaultValue: defaultValue}),
          returnValue: _FakePreference_0<int>()) as _i2.Preference<int>);
  @override
  _i2.Preference<double> getDouble(String? key, {double? defaultValue}) =>
      (super.noSuchMethod(
          Invocation.method(#getDouble, [key], {#defaultValue: defaultValue}),
          returnValue: _FakePreference_0<double>()) as _i2.Preference<double>);
  @override
  _i2.Preference<String> getString(String? key, {String? defaultValue}) =>
      (super.noSuchMethod(
          Invocation.method(#getString, [key], {#defaultValue: defaultValue}),
          returnValue: _FakePreference_0<String>()) as _i2.Preference<String>);
  @override
  _i2.Preference<List<String>> getStringList(String? key,
          {List<String>? defaultValue}) =>
      (super.noSuchMethod(
              Invocation.method(
                  #getStringList, [key], {#defaultValue: defaultValue}),
              returnValue: _FakePreference_0<List<String>>())
          as _i2.Preference<List<String>>);
  @override
  _i2.Preference<T> getCustomValue<T>(String? key,
          {T? defaultValue, _i5.PreferenceAdapter<T>? adapter}) =>
      (super.noSuchMethod(
          Invocation.method(#getCustomValue, [key],
              {#defaultValue: defaultValue, #adapter: adapter}),
          returnValue: _FakePreference_0<T>()) as _i2.Preference<T>);
  @override
  _i3.Future<bool> setBool(String? key, bool? value) =>
      (super.noSuchMethod(Invocation.method(#setBool, [key, value]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> setInt(String? key, int? value) =>
      (super.noSuchMethod(Invocation.method(#setInt, [key, value]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> setDouble(String? key, double? value) =>
      (super.noSuchMethod(Invocation.method(#setDouble, [key, value]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> setString(String? key, String? value) =>
      (super.noSuchMethod(Invocation.method(#setString, [key, value]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> setStringList(String? key, List<String>? values) =>
      (super.noSuchMethod(Invocation.method(#setStringList, [key, values]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> setCustomValue<T>(String? key, T? value,
          {_i5.PreferenceAdapter<T>? adapter}) =>
      (super.noSuchMethod(
          Invocation.method(#setCustomValue, [key, value], {#adapter: adapter}),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> remove(String? key) =>
      (super.noSuchMethod(Invocation.method(#remove, [key]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> clear() => (super.noSuchMethod(Invocation.method(#clear, []),
      returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
}

/// A class which mocks [Preference].
///
/// See the documentation for Mockito's code generation for more information.
class MockPreference<T> extends _i1.Mock implements _i2.Preference<T> {
  MockPreference() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String get key =>
      (super.noSuchMethod(Invocation.getter(#key), returnValue: '') as String);
  @override
  T get defaultValue => (super.noSuchMethod(Invocation.getter(#defaultValue),
      returnValue: _i6.defaultValue()) as T);
  @override
  bool get isBroadcast =>
      (super.noSuchMethod(Invocation.getter(#isBroadcast), returnValue: false)
          as bool);
  @override
  _i3.Future<int> get length => (super.noSuchMethod(Invocation.getter(#length),
      returnValue: Future<int>.value(0)) as _i3.Future<int>);
  @override
  _i3.Future<bool> get isEmpty =>
      (super.noSuchMethod(Invocation.getter(#isEmpty),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<T> get first => (super.noSuchMethod(Invocation.getter(#first),
      returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> get last => (super.noSuchMethod(Invocation.getter(#last),
      returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> get single => (super.noSuchMethod(Invocation.getter(#single),
      returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  T getValue() => (super.noSuchMethod(Invocation.method(#getValue, []),
      returnValue: _i6.getValue()) as T);
  @override
  _i3.Future<bool> setValue(T? value) =>
      (super.noSuchMethod(Invocation.method(#setValue, [value]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> clear() => (super.noSuchMethod(Invocation.method(#clear, []),
      returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Stream<T> asBroadcastStream(
          {void Function(_i3.StreamSubscription<T>)? onListen,
          void Function(_i3.StreamSubscription<T>)? onCancel}) =>
      (super.noSuchMethod(
          Invocation.method(#asBroadcastStream, [],
              {#onListen: onListen, #onCancel: onCancel}),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.StreamSubscription<T> listen(void Function(T)? onData,
          {Function? onError, void Function()? onDone, bool? cancelOnError}) =>
      (super.noSuchMethod(
              Invocation.method(#listen, [
                onData
              ], {
                #onError: onError,
                #onDone: onDone,
                #cancelOnError: cancelOnError
              }),
              returnValue: _FakeStreamSubscription_1<T>())
          as _i3.StreamSubscription<T>);
  @override
  _i3.Stream<T> where(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#where, [test]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<S> map<S>(S Function(T)? convert) =>
      (super.noSuchMethod(Invocation.method(#map, [convert]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Stream<E> asyncMap<E>(_i3.FutureOr<E>? Function(T)? convert) =>
      (super.noSuchMethod(Invocation.method(#asyncMap, [convert]),
          returnValue: Stream<E>.empty()) as _i3.Stream<E>);
  @override
  _i3.Stream<E> asyncExpand<E>(_i3.Stream<E>? Function(T)? convert) =>
      (super.noSuchMethod(Invocation.method(#asyncExpand, [convert]),
          returnValue: Stream<E>.empty()) as _i3.Stream<E>);
  @override
  _i3.Stream<T> handleError(Function? onError,
          {bool Function(dynamic)? test}) =>
      (super.noSuchMethod(
          Invocation.method(#handleError, [onError], {#test: test}),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<S> expand<S>(Iterable<S> Function(T)? convert) =>
      (super.noSuchMethod(Invocation.method(#expand, [convert]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Future<dynamic> pipe(_i3.StreamConsumer<T>? streamConsumer) =>
      (super.noSuchMethod(Invocation.method(#pipe, [streamConsumer]),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  _i3.Stream<S> transform<S>(_i3.StreamTransformer<T, S>? streamTransformer) =>
      (super.noSuchMethod(Invocation.method(#transform, [streamTransformer]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Future<T> reduce(T Function(T, T)? combine) =>
      (super.noSuchMethod(Invocation.method(#reduce, [combine]),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<S> fold<S>(S? initialValue, S Function(S, T)? combine) =>
      (super.noSuchMethod(Invocation.method(#fold, [initialValue, combine]),
          returnValue: Future<S>.value(null)) as _i3.Future<S>);
  @override
  _i3.Future<String> join([String? separator = r'']) =>
      (super.noSuchMethod(Invocation.method(#join, [separator]),
          returnValue: Future<String>.value('')) as _i3.Future<String>);
  @override
  _i3.Future<bool> contains(Object? needle) =>
      (super.noSuchMethod(Invocation.method(#contains, [needle]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<dynamic> forEach(void Function(T)? action) =>
      (super.noSuchMethod(Invocation.method(#forEach, [action]),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  _i3.Future<bool> every(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#every, [test]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> any(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#any, [test]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Stream<R> cast<R>() => (super.noSuchMethod(Invocation.method(#cast, []),
      returnValue: Stream<R>.empty()) as _i3.Stream<R>);
  @override
  _i3.Future<List<T>> toList() =>
      (super.noSuchMethod(Invocation.method(#toList, []),
          returnValue: Future<List<T>>.value(<T>[])) as _i3.Future<List<T>>);
  @override
  _i3.Future<Set<T>> toSet() =>
      (super.noSuchMethod(Invocation.method(#toSet, []),
          returnValue: Future<Set<T>>.value(<T>{})) as _i3.Future<Set<T>>);
  @override
  _i3.Future<E> drain<E>([E? futureValue]) =>
      (super.noSuchMethod(Invocation.method(#drain, [futureValue]),
          returnValue: Future<E>.value(null)) as _i3.Future<E>);
  @override
  _i3.Stream<T> take(int? count) =>
      (super.noSuchMethod(Invocation.method(#take, [count]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<T> takeWhile(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#takeWhile, [test]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<T> skip(int? count) =>
      (super.noSuchMethod(Invocation.method(#skip, [count]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<T> skipWhile(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#skipWhile, [test]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<T> distinct([bool Function(T, T)? equals]) =>
      (super.noSuchMethod(Invocation.method(#distinct, [equals]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Future<T> firstWhere(bool Function(T)? test, {T Function()? orElse}) =>
      (super.noSuchMethod(
          Invocation.method(#firstWhere, [test], {#orElse: orElse}),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> lastWhere(bool Function(T)? test, {T Function()? orElse}) =>
      (super.noSuchMethod(
          Invocation.method(#lastWhere, [test], {#orElse: orElse}),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> singleWhere(bool Function(T)? test, {T Function()? orElse}) =>
      (super.noSuchMethod(
          Invocation.method(#singleWhere, [test], {#orElse: orElse}),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> elementAt(int? index) =>
      (super.noSuchMethod(Invocation.method(#elementAt, [index]),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Stream<T> timeout(Duration? timeLimit,
          {void Function(_i3.EventSink<T>)? onTimeout}) =>
      (super.noSuchMethod(
          Invocation.method(#timeout, [timeLimit], {#onTimeout: onTimeout}),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
}

/// A class which mocks [Preference].
///
/// See the documentation for Mockito's code generation for more information.
class MockStringPreference<T> extends _i1.Mock implements _i2.Preference<T> {
  MockStringPreference() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String get key =>
      (super.noSuchMethod(Invocation.getter(#key), returnValue: '') as String);
  @override
  T get defaultValue => (super.noSuchMethod(Invocation.getter(#defaultValue),
      returnValue: _i6.defaultStringValue()) as T);
  @override
  bool get isBroadcast =>
      (super.noSuchMethod(Invocation.getter(#isBroadcast), returnValue: false)
          as bool);
  @override
  _i3.Future<int> get length => (super.noSuchMethod(Invocation.getter(#length),
      returnValue: Future<int>.value(0)) as _i3.Future<int>);
  @override
  _i3.Future<bool> get isEmpty =>
      (super.noSuchMethod(Invocation.getter(#isEmpty),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<T> get first => (super.noSuchMethod(Invocation.getter(#first),
      returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> get last => (super.noSuchMethod(Invocation.getter(#last),
      returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> get single => (super.noSuchMethod(Invocation.getter(#single),
      returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  T getValue() => (super.noSuchMethod(Invocation.method(#getValue, []),
      returnValue: _i6.getStringValue()) as T);
  @override
  _i3.Future<bool> setValue(T? value) =>
      (super.noSuchMethod(Invocation.method(#setValue, [value]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> clear() => (super.noSuchMethod(Invocation.method(#clear, []),
      returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Stream<T> asBroadcastStream(
          {void Function(_i3.StreamSubscription<T>)? onListen,
          void Function(_i3.StreamSubscription<T>)? onCancel}) =>
      (super.noSuchMethod(
          Invocation.method(#asBroadcastStream, [],
              {#onListen: onListen, #onCancel: onCancel}),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.StreamSubscription<T> listen(void Function(T)? onData,
          {Function? onError, void Function()? onDone, bool? cancelOnError}) =>
      (super.noSuchMethod(
              Invocation.method(#listen, [
                onData
              ], {
                #onError: onError,
                #onDone: onDone,
                #cancelOnError: cancelOnError
              }),
              returnValue: _FakeStreamSubscription_1<T>())
          as _i3.StreamSubscription<T>);
  @override
  _i3.Stream<T> where(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#where, [test]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<S> map<S>(S Function(T)? convert) =>
      (super.noSuchMethod(Invocation.method(#map, [convert]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Stream<E> asyncMap<E>(_i3.FutureOr<E>? Function(T)? convert) =>
      (super.noSuchMethod(Invocation.method(#asyncMap, [convert]),
          returnValue: Stream<E>.empty()) as _i3.Stream<E>);
  @override
  _i3.Stream<E> asyncExpand<E>(_i3.Stream<E>? Function(T)? convert) =>
      (super.noSuchMethod(Invocation.method(#asyncExpand, [convert]),
          returnValue: Stream<E>.empty()) as _i3.Stream<E>);
  @override
  _i3.Stream<T> handleError(Function? onError,
          {bool Function(dynamic)? test}) =>
      (super.noSuchMethod(
          Invocation.method(#handleError, [onError], {#test: test}),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<S> expand<S>(Iterable<S> Function(T)? convert) =>
      (super.noSuchMethod(Invocation.method(#expand, [convert]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Future<dynamic> pipe(_i3.StreamConsumer<T>? streamConsumer) =>
      (super.noSuchMethod(Invocation.method(#pipe, [streamConsumer]),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  _i3.Stream<S> transform<S>(_i3.StreamTransformer<T, S>? streamTransformer) =>
      (super.noSuchMethod(Invocation.method(#transform, [streamTransformer]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Future<T> reduce(T Function(T, T)? combine) =>
      (super.noSuchMethod(Invocation.method(#reduce, [combine]),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<S> fold<S>(S? initialValue, S Function(S, T)? combine) =>
      (super.noSuchMethod(Invocation.method(#fold, [initialValue, combine]),
          returnValue: Future<S>.value(null)) as _i3.Future<S>);
  @override
  _i3.Future<String> join([String? separator = r'']) =>
      (super.noSuchMethod(Invocation.method(#join, [separator]),
          returnValue: Future<String>.value('')) as _i3.Future<String>);
  @override
  _i3.Future<bool> contains(Object? needle) =>
      (super.noSuchMethod(Invocation.method(#contains, [needle]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<dynamic> forEach(void Function(T)? action) =>
      (super.noSuchMethod(Invocation.method(#forEach, [action]),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  _i3.Future<bool> every(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#every, [test]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> any(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#any, [test]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Stream<R> cast<R>() => (super.noSuchMethod(Invocation.method(#cast, []),
      returnValue: Stream<R>.empty()) as _i3.Stream<R>);
  @override
  _i3.Future<List<T>> toList() =>
      (super.noSuchMethod(Invocation.method(#toList, []),
          returnValue: Future<List<T>>.value(<T>[])) as _i3.Future<List<T>>);
  @override
  _i3.Future<Set<T>> toSet() =>
      (super.noSuchMethod(Invocation.method(#toSet, []),
          returnValue: Future<Set<T>>.value(<T>{})) as _i3.Future<Set<T>>);
  @override
  _i3.Future<E> drain<E>([E? futureValue]) =>
      (super.noSuchMethod(Invocation.method(#drain, [futureValue]),
          returnValue: Future<E>.value(null)) as _i3.Future<E>);
  @override
  _i3.Stream<T> take(int? count) =>
      (super.noSuchMethod(Invocation.method(#take, [count]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<T> takeWhile(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#takeWhile, [test]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<T> skip(int? count) =>
      (super.noSuchMethod(Invocation.method(#skip, [count]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<T> skipWhile(bool Function(T)? test) =>
      (super.noSuchMethod(Invocation.method(#skipWhile, [test]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Stream<T> distinct([bool Function(T, T)? equals]) =>
      (super.noSuchMethod(Invocation.method(#distinct, [equals]),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
  @override
  _i3.Future<T> firstWhere(bool Function(T)? test, {T Function()? orElse}) =>
      (super.noSuchMethod(
          Invocation.method(#firstWhere, [test], {#orElse: orElse}),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> lastWhere(bool Function(T)? test, {T Function()? orElse}) =>
      (super.noSuchMethod(
          Invocation.method(#lastWhere, [test], {#orElse: orElse}),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> singleWhere(bool Function(T)? test, {T Function()? orElse}) =>
      (super.noSuchMethod(
          Invocation.method(#singleWhere, [test], {#orElse: orElse}),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Future<T> elementAt(int? index) =>
      (super.noSuchMethod(Invocation.method(#elementAt, [index]),
          returnValue: Future<T>.value(null)) as _i3.Future<T>);
  @override
  _i3.Stream<T> timeout(Duration? timeLimit,
          {void Function(_i3.EventSink<T>)? onTimeout}) =>
      (super.noSuchMethod(
          Invocation.method(#timeout, [timeLimit], {#onTimeout: onTimeout}),
          returnValue: Stream<T>.empty()) as _i3.Stream<T>);
}
